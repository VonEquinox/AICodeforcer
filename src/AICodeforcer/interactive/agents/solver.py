"""Interactive problem solver agent."""

import os
import re
from datetime import datetime
from pathlib import Path
from typing import Callable, TextIO

from google import genai
from google.genai import types

from AICodeforcer.interactive.tools import interactive_stress_test
from AICodeforcer.standard.agents.cpp_translator import CppTranslator

SYSTEM_PROMPT = """<role>
You are a top-tier ICPC / CCPC competitive programming algorithm assistant specialized in solving interactive problems.
Your sole objective is: to reliably and reproducibly solve interactive problems and output AC-ready final code.

You can call tools to experiment, verify, and stress test your ideas and implementations.
Core Philosophy: Code experimentation first. Whenever a key idea/assumption/strategy emerges, write code to verify first, then draw conclusions.
</role>

<available-tools>
  <tool name="run_python_code">
    <signature>run_python_code(code, test_input)</signature>
    <description>Execute code and return output (for small-scale experiments, simulation, and verifying non-interactive logic)</description>
  </tool>
  <tool name="interactive_stress_test">
    <signature>interactive_stress_test(solution_code)</signature>
    <description>Interactive stress test verification (fixed 100 tests)</description>
    <note>Judge and data generator have been independently generated by the system, you only need to provide `solution_code`</note>
  </tool>
</available-tools>

<core-principles title="Must Not Be Violated">
  <principle>Correctness > Verifiability > Complexity Feasibility > Engineering Implementation</principle>
  <principle name="Experiment-Driven">Any unverified inference is an "assumption" and must be:
    <item>Logically proven, or</item>
    <item>Supported by Python small-scale experiments</item>
  </principle>
  <principle>Interactive strategy is essentially an experiment-driven algorithm: You must actively simulate and verify like a competitive programmer</principle>
  <principle>If you're mentally deducing more than 1-2 key steps, immediately write code to experiment</principle>
  <principle>Greedy / Binary Search / Encoding strategies: No experimental verification = Not trustworthy</principle>
</core-principles>

<problem-solving-process title="Mandatory - Must Be Demonstrated">
  <step name="Problem Restatement and Interaction Protocol Abstraction">
    <task>Restate the problem and interaction protocol in your own words</task>
    <task>Clarify query format, response format, termination conditions</task>
    <task>Clarify query count limits and error returns (e.g., `-1`)</task>
  </step>

  <step name="Candidate Strategies and Information Analysis">
    <task>Propose 1-3 strategies (e.g., binary search, divide and conquer, randomization, encoding, etc.)</task>
    <task>Estimate upper bound of query count</task>
    <task>Mark key points that need verification (monotonicity, encoding correctness, distinguishability)</task>
  </step>

  <step name="Python Experimentation and Simulation Verification" requirement="must-execute">
    <instruction>You must proactively use `run_python_code` to complete at least one of:</instruction>
    <task>Enumerate small-scale hidden states, verify if strategy can locate the answer</task>
    <task>Construct local simplified judge, simulate interaction flow</task>
    <task>Verify query count upper bound, encoding/decoding logic</task>
    <task>Find counterexamples and fix strategy</task>
    <requirement>Write code to verify whenever you have an idea, never just "self-consistent" in your head.</requirement>
  </step>

  <step name="Final Strategy Determination">
    <task>Clarify interaction flow and query sequence</task>
    <task>Clarify how to update state based on responses</task>
    <task>Provide query count upper bound and complexity</task>
  </step>

  <step name="Correctness Key Points">
    <task>Explain why the strategy can uniquely determine the answer</task>
    <task>Explain correctness of termination condition and answer output</task>
    <task>Explain why it won't exceed query count limit</task>
  </step>

  <step name="Interactive Implementation Details" level="competition">
    <task>All outputs must use `flush=True`</task>
    <task>Handle judge returning `-1`</task>
    <task>Strictly follow output format</task>
    <task>Count and prevent exceeding query limit</task>
  </step>

  <step name="Interactive Stress Test Verification" requirement="must-execute-before-submission">
    <instruction>Before outputting final code, you must call `interactive_stress_test(solution_code)`.</instruction>
    <note>If failed, read interaction log, fix strategy and implementation, stress test again.</note>
  </step>

  <step name="Final Submission Code">
    <task>Output complete, directly submittable Python code</task>
    <task>No debug output</task>
    <task>Use fast I/O</task>
  </step>
</problem-solving-process>

<code-standards priority="critical">
  <standard name="Tool Call Isolation" importance="must-remember">
    <rule>Each tool call is a fresh interpreter environment - Previously defined functions/variables (like `eval_f`, `solve`) do not exist in the next call.</rule>
    <rule>No cross-call dependencies: Each call must redefine all needed functions/variables/constants.</rule>
    <rule>Code must be complete, self-contained, independently runnable, explicitly import standard library.</rule>
    <rule>Pre-call self-check: Confirm all used functions/variables are defined, won't throw NameError/ImportError/AttributeError</rule>
  </standard>

  <standard name="Code Must Be Complete and Self-Contained" type="hard-requirement">
    <forbidden>Never reference any symbols (functions, classes, variables, constants) not defined or imported within that code block</forbidden>
    <rule>All helper functions (such as `check`, `valid`, `ok`, `solve`, etc.) must be fully implemented in the same code block</rule>
    <rule>Required modules must be explicitly `import`ed, use Python standard library only, no third-party libraries</rule>
    <rule>Code must call main logic at the bottom, ensure observable output (print)</rule>
  </standard>

  <standard name="Interactive Output Standards">
    <rule>All `print` must use `flush=True`</rule>
    <rule>Query format is usually `? ...`, answer format is usually `! ...` (follow problem statement)</rule>
    <rule>Must exit immediately upon receiving `-1` (`sys.exit()`)</rule>
    <rule name="Output format is protocol" priority="critical">
      <item>Output must be exactly consistent with problem requirements, including format, separators, newlines, etc.</item>
      <forbidden>Never output debug information, extra explanations, or anything not required by the problem</forbidden>
      <warning>Wrong output format = WA, even if algorithm logic is correct</warning>
    </rule>
  </standard>
</code-standards>

<code-template name="Interactive Code Template" language="python">
import sys

def main():
    # Read initial information (if any)
    n = int(input())

    # Interaction loop
    while True:
        # Send query
        print(f"? {query}", flush=True)

        # Read response
        response = input()

        # Handle error
        if response == "-1":
            sys.exit()

        # Check if finished
        if found_answer:
            print(f"! {answer}", flush=True)
            break

if __name__ == "__main__":
    main()
</code-template>

<completion-flag>
  <strict-requirements>
    <requirement>Must call `run_python_code` to do at least one small-scale experiment or simulation verification</requirement>
    <requirement>Must call `interactive_stress_test` for stress test verification (fixed 100 tests)</requirement>
    <requirement>Must see "INTERACTIVE STRESS TEST PASSED" returned to consider stress test passed</requirement>
    <requirement>Only after all above steps are completed and passed can you output "ALL_TESTS_PASSED"</requirement>
  </strict-requirements>

  <forbidden-behaviors>
    <forbidden>Never claim tests passed without calling tools</forbidden>
    <forbidden>Never skip stress test verification</forbidden>
    <forbidden>Never claim stress test passed without seeing "INTERACTIVE STRESS TEST PASSED"</forbidden>
    <forbidden>Never output "ALL_TESTS_PASSED" without actually executing experiments</forbidden>
  </forbidden-behaviors>
</completion-flag>
"""

TOOL_DECLARATIONS = [
    types.Tool(function_declarations=[
        types.FunctionDeclaration(
            name="run_python_code",
            description="执行 Python 代码并返回结果。用于测试非交互逻辑。",
            parameters=types.Schema(
                type=types.Type.OBJECT,
                properties={
                    "code": types.Schema(
                        type=types.Type.STRING,
                        description="要执行的 Python 代码",
                    ),
                    "test_input": types.Schema(
                        type=types.Type.STRING,
                        description="提供给代码的测试输入",
                    ),
                },
                required=["code", "test_input"],
            ),
        ),
        types.FunctionDeclaration(
            name="interactive_stress_test",
            description="交互对拍验证工具：运行 100 次交互测试验证你的代码。你只需提供 solution_code，评测机和数据生成器已由系统生成。代码必须完整自包含，所有 print 必须使用 flush=True。",
            parameters=types.Schema(
                type=types.Type.OBJECT,
                properties={
                    "solution_code": types.Schema(
                        type=types.Type.STRING,
                        description="要验证的交互代码（完整自包含，所有 print 使用 flush=True）",
                    ),
                },
                required=["solution_code"],
            ),
        ),
    ])
]


class InteractiveSolver:
    """Gemini-powered interactive problem solver."""

    def __init__(
        self,
        api_key: str | None = None,
        base_url: str | None = None,
        model: str | None = None,
        log_dir: str | None = None,
    ):
        self.api_key = api_key or os.environ.get("GEMINI_API_KEY")
        if not self.api_key:
            raise ValueError("API key required")

        self.base_url = base_url or os.environ.get("GEMINI_BASE_URL")
        self.model = model or os.environ.get("GEMINI_MODEL", "gemini-2.5-flash")

        if self.base_url:
            self.client = genai.Client(
                api_key=self.api_key,
                http_options=types.HttpOptions(base_url=self.base_url),
            )
        else:
            self.client = genai.Client(api_key=self.api_key)

        self._contents: list[types.Content] = []
        self._config: types.GenerateContentConfig | None = None
        self._last_verified_code: str | None = None
        self._last_code: str | None = None

        # Preprocessed judge and generator
        self._generator_code: str | None = None
        self._judge_code: str | None = None

        # Logging
        self._log_dir = Path(log_dir) if log_dir else Path("logs")
        self._log_file: TextIO | None = None
        self._log_path: Path | None = None

        # C++ translator
        self._cpp_translator = CppTranslator(
            api_key=self.api_key,
            base_url=self.base_url,
            model=self.model,
        )
        self._cpp_code: str | None = None

    def _init_log(self, problem_text: str) -> None:
        """Initialize log file."""
        self._log_dir.mkdir(parents=True, exist_ok=True)
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        self._log_path = self._log_dir / f"interactive_{timestamp}.log"
        self._log_file = open(self._log_path, "w", encoding="utf-8")
        self._log(f"{'='*80}")
        self._log("AICodeforcer 交互题求解日志")
        self._log(f"时间: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        self._log(f"模型: {self.model}")
        self._log(f"{'='*80}")
        self._log(f"\n{'='*80}")
        self._log("题目内容")
        self._log(f"{'='*80}")
        self._log(problem_text)
        self._log(f"{'='*80}\n")

    def _log(self, message: str) -> None:
        """Write to log."""
        if self._log_file:
            self._log_file.write(message + "\n")
            self._log_file.flush()

    def _log_tool_call(self, func_name: str, func_args: dict, result: str) -> None:
        """Log tool call details."""
        self._log(f"\n{'='*80}")
        self._log(f"工具调用: {func_name}")
        self._log(f"时间: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        self._log(f"{'='*80}")

        if func_name == "run_python_code":
            self._log("\n--- 代码 ---")
            self._log(func_args.get("code", ""))
            self._log("\n--- 输入 ---")
            self._log(func_args.get("test_input", ""))
        elif func_name == "interactive_stress_test":
            self._log("\n--- 交互代码 (solution_code) ---")
            self._log(func_args.get("solution_code", ""))

        self._log("\n--- 执行结果 ---")
        self._log(result)
        self._log(f"{'='*80}\n")

    def _log_response(self, turn: int, response_text: str) -> None:
        """Log model response."""
        self._log(f"\n{'='*80}")
        self._log(f"Turn {turn} - 模型响应")
        self._log(f"{'='*80}")
        self._log(response_text)
        self._log(f"{'='*80}\n")

    def _close_log(self) -> None:
        """Close log file."""
        if self._log_file:
            self._log(f"\n{'='*80}")
            self._log(f"日志结束: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
            self._log(f"{'='*80}")
            self._log_file.close()
            self._log_file = None
            print(f"\n[日志] 已保存到: {self._log_path}")

    def solve(
        self,
        problem_text: str,
        generator_code: str,
        judge_code: str,
        max_attempts: int = 50,
        on_attempt: Callable[[int, str], None] | None = None,
    ) -> tuple[str | None, str | None, bool]:
        """Solve an interactive problem.

        Args:
            problem_text: The problem statement
            generator_code: Data generator code
            judge_code: Judge/interactor code
            max_attempts: Maximum attempts
            on_attempt: Callback for each attempt

        Returns:
            (python_code, cpp_code, success) tuple
        """
        self._generator_code = generator_code
        self._judge_code = judge_code

        self._init_log(problem_text)
        self._log("\n--- 数据生成器代码 ---")
        self._log(generator_code)
        self._log("\n--- 评测机代码 ---")
        self._log(judge_code)

        try:
            return self._solve_impl(problem_text, max_attempts, on_attempt)
        finally:
            self._close_log()

    def _translate_to_cpp(self, python_code: str | None) -> str | None:
        """Translate Python code to C++."""
        if not python_code:
            return None

        cpp_code = self._cpp_translator.translate(python_code)
        if cpp_code:
            self._cpp_code = cpp_code
            self._log("\n--- C++ 翻译结果 ---")
            self._log(cpp_code)
        else:
            self._log("[翻译] C++ 翻译失败")

        return cpp_code

    def _solve_impl(
        self,
        problem_text: str,
        max_attempts: int,
        on_attempt: Callable[[int, str], None] | None,
    ) -> tuple[str | None, str | None, bool]:
        """Actual solving logic."""
        from AICodeforcer.standard.tools import run_python_code

        config = types.GenerateContentConfig(
            system_instruction=SYSTEM_PROMPT,
            tools=TOOL_DECLARATIONS,
            automatic_function_calling=types.AutomaticFunctionCallingConfig(disable=True),
            temperature=1.0,
            thinking_config=types.ThinkingConfig(thinking_level="high"),
        )

        contents: list[types.Content] = []

        initial_prompt = f"""请解决以下交互题：

{problem_text}

请仔细分析交互协议，设计查询策略，编写交互代码，并使用工具测试验证。
记住：必须调用 interactive_stress_test 进行对拍验证。
所有 print 语句必须使用 flush=True。"""

        contents.append(types.Content(
            role="user",
            parts=[types.Part.from_text(text=initial_prompt)],
        ))

        last_code: str | None = None
        attempt_count = 0
        stress_test_passed = False
        verified_code: str | None = None

        tool_functions = {
            "run_python_code": run_python_code,
            "interactive_stress_test": self._run_stress_test,
        }

        for turn in range(max_attempts):
            response = None
            for retry in range(30):
                try:
                    response = self.client.models.generate_content(
                        model=self.model,
                        contents=contents,
                        config=config,
                    )
                    break
                except Exception as e:
                    print(f"[Turn {turn + 1}] 请求失败 (重试 {retry + 1}/30): {e}")
                    self._log(f"[Turn {turn + 1}] 请求失败 (重试 {retry + 1}/30): {e}")
                    if retry == 29:
                        raise
                    import time
                    time.sleep(5)

            if not response:
                break

            candidate = response.candidates[0] if response.candidates else None
            if not candidate or not candidate.content:
                print(f"[Turn {turn + 1}] 无响应内容")
                self._log(f"[Turn {turn + 1}] 无响应内容")
                break

            response_content = candidate.content
            contents.append(response_content)

            response_text = ""
            function_calls = []

            for part in response_content.parts:
                if part.text:
                    response_text += part.text
                if part.function_call:
                    function_calls.append(part.function_call)

            print(f"\n{'='*60}")
            print(f"Turn {turn + 1}")
            print("=" * 60)
            if response_text:
                preview = response_text[:1500] if len(response_text) > 1500 else response_text
                print(preview)
                if len(response_text) > 1500:
                    print(f"... (truncated, total {len(response_text)} chars)")

            self._log_response(turn + 1, response_text)

            code = self._extract_code(response_text)
            if code:
                last_code = code
                self._last_code = code
                attempt_count += 1
                if on_attempt:
                    on_attempt(attempt_count, code)

            if "ALL_TESTS_PASSED" in response_text and not function_calls:
                if stress_test_passed and verified_code:
                    print("\n[程序化校验] 对拍已通过，返回验证过的代码")
                    self._log("[程序化校验] 对拍已通过，返回验证过的代码")
                    self._contents = contents
                    self._config = config
                    self._last_verified_code = verified_code
                    self._last_code = verified_code
                    cpp_code = self._translate_to_cpp(verified_code)
                    return verified_code, cpp_code, True
                else:
                    print("\n[程序化校验] 模型声称通过但未检测到对拍通过，要求重新验证")
                    self._log("[程序化校验] 模型声称通过但未检测到对拍通过，要求重新验证")
                    contents.append(types.Content(
                        role="user",
                        parts=[types.Part.from_text(
                            text="你声称 ALL_TESTS_PASSED，但系统未检测到对拍通过。请调用 interactive_stress_test 工具进行对拍验证。"
                        )],
                    ))
                    continue

            if function_calls:
                print(f"\n[工具调用] 共 {len(function_calls)} 个")
                function_responses = []

                for fc in function_calls:
                    func_name = fc.name
                    func_args = dict(fc.args) if fc.args else {}

                    if func_name == "interactive_stress_test":
                        solution_code = func_args.get("solution_code", "")
                        func_args = {"solution_code": solution_code}
                    elif func_name == "run_python_code":
                        allowed_keys = {"code", "test_input"}
                        func_args = {k: v for k, v in func_args.items() if k in allowed_keys}

                    print(f"  - {func_name}({', '.join(f'{k}=...' for k in func_args.keys())})")

                    if func_name in tool_functions:
                        try:
                            result = tool_functions[func_name](**func_args)
                        except Exception as e:
                            result = f"Error: {e}"
                    else:
                        result = f"Unknown function: {func_name}"

                    self._log_tool_call(func_name, func_args, result)

                    if func_name == "interactive_stress_test" and "INTERACTIVE STRESS TEST PASSED" in result:
                        stress_test_passed = True
                        verified_code = func_args.get("solution_code")
                        print("    [程序化校验] 对拍通过！已记录验证代码")
                    elif func_name == "interactive_stress_test" and "INTERACTIVE TEST FAILED" in result:
                        stress_test_passed = False
                        verified_code = None
                        print("    [程序化校验] 对拍失败，重置验证状态")

                    result_preview = result[:500] if len(result) > 500 else result
                    print(f"    结果: {result_preview}")
                    if len(result) > 500:
                        print(f"    ... (truncated, total {len(result)} chars)")

                    function_responses.append(types.Part.from_function_response(
                        name=func_name,
                        response={"result": result},
                    ))

                contents.append(types.Content(
                    role="user",
                    parts=function_responses,
                ))

                if stress_test_passed and verified_code:
                    print("\n[程序化校验] 对拍已通过 100 次测试，直接返回验证过的代码")
                    self._log("[程序化校验] 对拍已通过 100 次测试，直接返回验证过的代码")
                    self._contents = contents
                    self._config = config
                    self._last_verified_code = verified_code
                    self._last_code = verified_code
                    cpp_code = self._translate_to_cpp(verified_code)
                    return verified_code, cpp_code, True
            else:
                if turn < max_attempts - 1:
                    contents.append(types.Content(
                        role="user",
                        parts=[types.Part.from_text(
                            text="请继续。记住必须调用工具验证代码。如果所有测试都通过了，请输出 'ALL_TESTS_PASSED' 并给出最终代码。"
                        )],
                    ))

        self._contents = contents
        self._config = config
        self._last_code = last_code
        cpp_code = self._translate_to_cpp(last_code)
        return last_code, cpp_code, False

    def _run_stress_test(self, solution_code: str) -> str:
        """Run interactive stress test with injected generator and judge."""
        if not self._generator_code or not self._judge_code:
            return "Error: 评测机或数据生成器未生成"

        return interactive_stress_test(
            solution_code=solution_code,
            generator_code=self._generator_code,
            judge_code=self._judge_code,
            num_tests=100,
        )

    def continue_solving(
        self,
        feedback: str,
        max_attempts: int = 30,
        on_attempt: Callable[[int, str], None] | None = None,
    ) -> tuple[str | None, str | None, bool]:
        """Continue solving based on user feedback.

        Returns:
            (python_code, cpp_code, success) tuple
        """
        if not self._contents or not self._config:
            raise RuntimeError("没有可继续的对话，请先调用 solve()")

        from AICodeforcer.standard.tools import run_python_code

        # Reopen log file in append mode
        if self._log_path and not self._log_file:
            self._log_file = open(self._log_path, "a", encoding="utf-8")

        self._log(f"\n{'='*80}")
        self._log("继续优化 - 用户反馈")
        self._log(f"时间: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        self._log("=" * 80)
        self._log(f"反馈内容: {feedback}")
        self._log("=" * 80 + "\n")

        try:
            return self._continue_solving_impl(feedback, max_attempts, on_attempt, run_python_code)
        finally:
            self._close_log()

    def _continue_solving_impl(
        self,
        feedback: str,
        max_attempts: int,
        on_attempt: Callable[[int, str], None] | None,
        run_python_code,
    ) -> tuple[str | None, str | None, bool]:
        """Continue solving implementation."""
        contents = self._contents
        config = self._config

        feedback_prompt = f"""用户提交代码后收到以下反馈：

{feedback}

请根据这个反馈分析问题原因，优化你的交互代码，然后：
1. 使用 interactive_stress_test 进行对拍验证
2. 确保对拍通过后输出 "ALL_TESTS_PASSED" 和最终代码

注意：
- TLE: 可能是查询次数过多或策略效率低
- WA: 交互逻辑有误，检查查询和答案格式
- RE: 可能是没有正确处理评测机的回复"""

        contents.append(types.Content(
            role="user",
            parts=[types.Part.from_text(text=feedback_prompt)],
        ))

        last_code: str | None = self._last_code or self._last_verified_code
        attempt_count = 0
        stress_test_passed = False
        verified_code: str | None = None

        tool_functions = {
            "run_python_code": run_python_code,
            "interactive_stress_test": self._run_stress_test,
        }

        for turn in range(max_attempts):
            response = None
            for retry in range(30):
                try:
                    response = self.client.models.generate_content(
                        model=self.model,
                        contents=contents,
                        config=config,
                    )
                    break
                except Exception as e:
                    print(f"[Turn {turn + 1}] 请求失败 (重试 {retry + 1}/30): {e}")
                    self._log(f"[Turn {turn + 1}] 请求失败 (重试 {retry + 1}/30): {e}")
                    if retry == 29:
                        raise
                    import time
                    time.sleep(5)

            if not response:
                break

            candidate = response.candidates[0] if response.candidates else None
            if not candidate or not candidate.content:
                break

            response_content = candidate.content
            contents.append(response_content)

            response_text = ""
            function_calls = []

            for part in response_content.parts:
                if part.text:
                    response_text += part.text
                if part.function_call:
                    function_calls.append(part.function_call)

            print(f"\n{'='*60}")
            print(f"Turn {turn + 1}")
            print("=" * 60)
            if response_text:
                preview = response_text[:1500] if len(response_text) > 1500 else response_text
                print(preview)
                if len(response_text) > 1500:
                    print(f"... (truncated, total {len(response_text)} chars)")

            self._log_response(turn + 1, response_text)

            code = self._extract_code(response_text)
            if code:
                last_code = code
                self._last_code = code
                attempt_count += 1
                if on_attempt:
                    on_attempt(attempt_count, code)

            if "ALL_TESTS_PASSED" in response_text and not function_calls:
                if stress_test_passed and verified_code:
                    self._contents = contents
                    self._last_verified_code = verified_code
                    self._last_code = verified_code
                    cpp_code = self._translate_to_cpp(verified_code)
                    return verified_code, cpp_code, True
                else:
                    contents.append(types.Content(
                        role="user",
                        parts=[types.Part.from_text(
                            text="你声称 ALL_TESTS_PASSED，但系统未检测到对拍通过。请调用 interactive_stress_test 工具进行对拍验证。"
                        )],
                    ))
                    continue

            if function_calls:
                print(f"\n[工具调用] 共 {len(function_calls)} 个")
                function_responses = []

                for fc in function_calls:
                    func_name = fc.name
                    func_args = dict(fc.args) if fc.args else {}

                    if func_name == "interactive_stress_test":
                        solution_code = func_args.get("solution_code", "")
                        func_args = {"solution_code": solution_code}
                    elif func_name == "run_python_code":
                        allowed_keys = {"code", "test_input"}
                        func_args = {k: v for k, v in func_args.items() if k in allowed_keys}

                    print(f"  - {func_name}({', '.join(f'{k}=...' for k in func_args.keys())})")

                    if func_name in tool_functions:
                        try:
                            result = tool_functions[func_name](**func_args)
                        except Exception as e:
                            result = f"Error: {e}"
                    else:
                        result = f"Unknown function: {func_name}"

                    self._log_tool_call(func_name, func_args, result)

                    if func_name == "interactive_stress_test" and "INTERACTIVE STRESS TEST PASSED" in result:
                        stress_test_passed = True
                        verified_code = func_args.get("solution_code")
                        print("    [程序化校验] 对拍通过！")
                    elif func_name == "interactive_stress_test" and "INTERACTIVE TEST FAILED" in result:
                        stress_test_passed = False
                        verified_code = None

                    result_preview = result[:500] if len(result) > 500 else result
                    print(f"    结果: {result_preview}")
                    if len(result) > 500:
                        print(f"    ... (truncated, total {len(result)} chars)")

                    function_responses.append(types.Part.from_function_response(
                        name=func_name,
                        response={"result": result},
                    ))

                contents.append(types.Content(
                    role="user",
                    parts=function_responses,
                ))

                if stress_test_passed and verified_code:
                    self._contents = contents
                    self._last_verified_code = verified_code
                    self._last_code = verified_code
                    cpp_code = self._translate_to_cpp(verified_code)
                    return verified_code, cpp_code, True
            else:
                if turn < max_attempts - 1:
                    contents.append(types.Content(
                        role="user",
                        parts=[types.Part.from_text(
                            text="请继续。记住必须调用工具验证代码。"
                        )],
                    ))

        self._contents = contents
        self._last_code = last_code
        cpp_code = self._translate_to_cpp(last_code)
        return last_code, cpp_code, False

    def _extract_code(self, text: str) -> str | None:
        """Extract Python code from response text."""
        patterns = [
            r"```python\n(.*?)```",
            r"```py\n(.*?)```",
            r"```\n(.*?)```",
        ]

        for pattern in patterns:
            matches = re.findall(pattern, text, re.DOTALL)
            if matches:
                return matches[-1].strip()

        return None
